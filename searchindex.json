{"categories":[],"posts":[{"content":"最近在团队项目中发现，应用在使用unixodbc bind方式执行insert语句时报错：\nERROR: invalid byte sequence for encoding “UTF8“: 0x08  遇到这个错误，最开始我们以为是客户端或服务端字符编码不对，因此在pg服务端查看\n#PG数据库服务端编码查询 show server_encoding  #PG数据库客户端编码查询 show client_encoding  发现服务端为UTF8，客户端为SQL-ASCII，于是查看官方文档，使用\nexport PGCLIENTENCODING=UTF8  这时通过psql连接数据库后查看到的编码已经为UTF8了。但是问题并没有解决。\n此时只好重新梳理代码调用栈。 如下是项目应用的调用栈，Application为应用代码，DbApi为基于Poco的数据库应用抽象API，unixODBC数据库驱动管理器为访问PG数据库，使用psqlODBC数据库驱动。\nflowchart LR Appication --\u0026gt; DbApi --\u0026gt; unixODBC --\u0026gt; psqlODBC  应用层使用拼sql的方式执行语句是没有问题的。这里的功能，应用层使用bind参数绑定方式执行sql，这对于对某个表批量插入数据来说，效率更好。首先准备sql语句\ninsert int table_r(no, name, age) value ($1, $2, $3)  经过for循环，批量对参数值进行绑定。如此仅一次insert模版，后续仅传送绑定参数即可，节约了与PG服务器通信的带宽。\n理清流程后，逐步在Application层、DbApi层进行了绑定参数值的打印，发现并没有出现乱码。 由于unixODBC和psqlODBC都是so形式存在，源代码需要下载。因此先绕过数据库驱动，在PG服务端查看日志。PG服务端日志默认在pg_log下。使用psql登陆服务端执行如下语句打开详细日志\nalter system set log_statement to 'all'; select pg_reload_conf();  查看日志发现发送到服务端的绑定参数已经乱码。由此可推测数据应该是在客户端代码部分出错的。\nunixODBC只是驱动管理器，提供了通用的数据库操作API，但是具体实现还是psqlODBC。因此考虑查看psqlODBC日志。\n官网上psqlODBC介绍了两种日志：MyLog和CommLog，但是并没有具体的说明。结合psqlODBC源码，需要设置odbc.ini中特定数据库的参数(0为关闭；1为打开；2为详细日志)\n[CM_DB] ... Debug=2 CommLog=2  如此就能在/tmp下看到mylog_process_202201203.log和commlog_process_20221203.log的日志文件了。 有了日志文件，再结合源码，就能帮助我们更好的定位问题。\n最后，我们定位到，数据绑定过程中，引用入参被传入到一个临时的string类型变量中。但是绑定和sql执行是分为2个函数。当绑定函数结束时，这个临时变量会被释放。在执行时，临时变量在内存中的值变成乱码了。因此导致执行时字符乱码。解决问题后，sql语句能正常执行了。\n","id":0,"section":"posts","summary":"最近在团队项目中发现，应用在使用unixodbc bind方式执行insert语句时报错： ERROR: invalid byte sequence for encoding “UTF8“: 0x08 遇到这个错误，最开始我们","tags":["unixODBC","psqlODBC","SQLBindParameter"],"title":"UTF8字符解析错误PG执行失败","uri":"https://ketop.github.io/2022/08/psqlodbc/","year":"2022"},{"content":"饿汉模式 在程序开始时就完成实例化操作。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; class Singleton { private: Singleton(){ std::cout \u0026lt;\u0026lt; \u0026quot;Constructor\u0026quot; \u0026lt;\u0026lt; std::endl; } ~Singleton() { std::cout \u0026lt;\u0026lt; \u0026quot;Deconstructor\u0026quot; \u0026lt;\u0026lt; std::endl; } Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;)=delete; static Singleton m_instance; public: static Singleton* getInstance() { return \u0026amp;m_instance; } void echo() { std::cout \u0026lt;\u0026lt; \u0026quot;Print All Message.\u0026quot; \u0026lt;\u0026lt; std::endl; } }; Singleton Singleton::m_instance; int main() { Singleton* pst = Singleton::getInstance(); pst-\u0026gt;echo(); return 0; }  将m_instance声明为Singleton的指针类型\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; class Singleton { private: Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;)=delete; static Singleton* m_instance; Singleton(){ std::cout \u0026lt;\u0026lt; \u0026quot;Constructor\u0026quot; \u0026lt;\u0026lt; std::endl; } ~Singleton() { std::cout \u0026lt;\u0026lt; \u0026quot;Deconstructor\u0026quot; \u0026lt;\u0026lt; std::endl; } public: static Singleton* getInstance() { return m_instance; } void echo() { std::cout \u0026lt;\u0026lt; \u0026quot;Print All Message.\u0026quot; \u0026lt;\u0026lt; std::endl; } }; Singleton* Singleton::m_instance(new Singleton()); int main() { Singleton* pst = Singleton::getInstance(); pst-\u0026gt;echo(); return 0; }  此时单例资源无法释放，使用valgrind来测试下\nvalgrind --tool=memcheck --leak-check=full --show-leak-kinds=all --show-reachable=yes ./singleton ==6146== Memcheck, a memory error detector ==6146== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al. ==6146== Using Valgrind-3.15.0 and LibVEX; rerun with -h for copyright info ==6146== Command: ./singleton4 ==6146== Constructor Print All Message. ==6146== ==6146== HEAP SUMMARY: ==6146== in use at exit: 1 bytes in 1 blocks ==6146== total heap usage: 3 allocs, 2 frees, 73,729 bytes allocated ==6146== ==6146== 1 bytes in 1 blocks are still reachable in loss record 1 of 1 ==6146== at 0x483BE63: operator new(unsigned long) (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so) ==6146== by 0x109299: __static_initialization_and_destruction_0(int, int) (singleton4.cpp:22) ==6146== by 0x1092E7: _GLOBAL__sub_I__ZN9Singleton10m_instanceE (singleton4.cpp:32) ==6146== by 0x1093BC: __libc_csu_init (in /home/ketop/project/designpattern/singleton4) ==6146== by 0x4A7903F: (below main) (libc-start.c:264) ==6146== ==6146== LEAK SUMMARY: ==6146== definitely lost: 0 bytes in 0 blocks ==6146== indirectly lost: 0 bytes in 0 blocks ==6146== possibly lost: 0 bytes in 0 blocks ==6146== still reachable: 1 bytes in 1 blocks ==6146== suppressed: 0 bytes in 0 blocks ==6146== ==6146== For lists of detected and suppressed errors, rerun with: -s ==6146== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)  发现静态资源没有被释放，still reachable依然保留内存。由于析构函数被声明为private，因此只能再声明个static函数来调用析构函数。\nstatic void destory(){ if(m_instance){ delete m_instance; } } //调用destory来释放内存 pst-\u0026gt;destory();  但是以上方式如果忘记调用，则无法释放资源，还是不够完美。如何能自动释放呢？\n 内部类  #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; class Singleton { private: Singleton(){ std::cout \u0026lt;\u0026lt; \u0026quot;Constructor\u0026quot; \u0026lt;\u0026lt; std::endl; } ~Singleton() { std::cout \u0026lt;\u0026lt; \u0026quot;Deconstructor\u0026quot; \u0026lt;\u0026lt; std::endl; } Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;)=delete; static Singleton* m_instance; class CGarbo { public: CGarbo(){} ~CGarbo(){ if(m_instance){ delete m_instance; } } }; static CGarbo m_garbo; public: static Singleton* getInstance() { return m_instance; } void echo() { std::cout \u0026lt;\u0026lt; \u0026quot;Print All Message.\u0026quot; \u0026lt;\u0026lt; std::endl; } }; Singleton* Singleton::m_instance=new Singleton(); Singleton::CGarbo Singleton::m_garbo; int main() { Singleton* pst = Singleton::getInstance(); pst-\u0026gt;echo(); return 0; }  shared_ptr智能指针  结合C++的shared_ptr自动释放资源的特性，可以采用以下方式来释放。\n 定义析构函数为public，但是有可能被用户误用析构函数 定义一个删除器，形参为指针  #include \u0026lt;memory\u0026gt; class Singleton { private: Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;)=delete; static std::shared_ptr\u0026lt;Singleton\u0026gt; m_instance; Singleton(){ std::cout \u0026lt;\u0026lt; \u0026quot;Constructor\u0026quot; \u0026lt;\u0026lt; std::endl; } ~Singleton() { std::cout \u0026lt;\u0026lt; \u0026quot;Deconstructor\u0026quot; \u0026lt;\u0026lt; std::endl; } public: //定义删除器 static void destory(Singleton* ptr) { std::cout \u0026lt;\u0026lt; \u0026quot;destroy\u0026quot; \u0026lt;\u0026lt; std::endl; if(ptr) { delete ptr; } } static std::shared_ptr\u0026lt;Singleton\u0026gt; getInstance() { return m_instance; } void echo() { std::cout \u0026lt;\u0026lt; \u0026quot;Print All Message.\u0026quot; \u0026lt;\u0026lt; std::endl; } }; std::shared_ptr\u0026lt;Singleton\u0026gt; Singleton::m_instance(new Singleton(), Singleton::destory); int main() { std::shared_ptr\u0026lt;Singleton\u0026gt; pst = Singleton::getInstance(); pst-\u0026gt;echo(); return 0; }  懒汉模式 在需要的时候实例化，构造时并不实例化。\n需要处理的问题：多线程安全\n静态局部变量 [Best Practice]  If control enters the declaration concurrently while the variable is being initialized, the concurrent execution shall wait for completion of the initialization.\n如果当变量在初始化的时候，并发同时进入声明语句，并发线程将会阻塞等待初始化结束。\n​ 《Effective C++》作者 Meyers\n #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; class Singleton { private: Singleton(){ std::cout \u0026lt;\u0026lt; \u0026quot;Constructor\u0026quot; \u0026lt;\u0026lt; std::endl; } ~Singleton() { std::cout \u0026lt;\u0026lt; \u0026quot;Deconstructor\u0026quot; \u0026lt;\u0026lt; std::endl; } Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;)=delete; public: //线程安全：《Effective C++》作者Meyers // static Singleton* getInstance() { static Singleton m_instance;//调用时才构造，与饿汉差异很小 return \u0026amp;m_instance; } void echo() { std::cout \u0026lt;\u0026lt; \u0026quot;Print All Message.\u0026quot; \u0026lt;\u0026lt; std::endl; } }; int main() { Singleton* pst = Singleton::getInstance(); pst-\u0026gt;echo(); return 0; }  更优雅的做法是返回引用，因为局部静态变量把那个不是分配在堆上，直接返回引用显的更一致。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; class Singleton { private: Singleton(){ std::cout \u0026lt;\u0026lt; \u0026quot;Constructor\u0026quot; \u0026lt;\u0026lt; std::endl; } ~Singleton() { std::cout \u0026lt;\u0026lt; \u0026quot;Deconstructor\u0026quot; \u0026lt;\u0026lt; std::endl; } Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;)=delete; public: static Singleton\u0026amp; getInstance() { static Singleton m_instance; return m_instance; } void echo() { std::cout \u0026lt;\u0026lt; \u0026quot;Print All Message.\u0026quot; \u0026lt;\u0026lt; std::endl; } }; int main() { Singleton\u0026amp; pst = Singleton::getInstance(); pst.echo(); return 0; }  动态方式， double check 另一种是使用内部类的方式自动释放静态类的内存。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;mutex\u0026gt; using std::cout; using std::endl; using std::mutex; using std::lock_guard; class Singleton{ public: static Singleton* getInstance(){ if(_instance == nullptr) { lock_guard\u0026lt;mutex\u0026gt; lock(m_mutex); if(_instance == nullptr) { _instance = new Singleton(); } } return _instance; } void run() { std::cout \u0026lt;\u0026lt; \u0026quot;run\u0026quot; \u0026lt;\u0026lt; std::endl; } private: Singleton(){ cout \u0026lt;\u0026lt; \u0026quot;Constructor\u0026quot; \u0026lt;\u0026lt; endl; } ~Singleton(){ cout \u0026lt;\u0026lt; \u0026quot;Deconstructor\u0026quot; \u0026lt;\u0026lt; endl; } static mutex m_mutex; Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp; )=delete; static Singleton* _instance; class CGarbo { public: CGarbo(){} ~CGarbo() { if (_instance) { delete _instance; } } }; static CGarbo m_garbo; }; Singleton* Singleton::_instance=nullptr; Singleton::CGarbo Singleton::m_garbo; mutex Singleton::m_mutex; int main() { Singleton* sp = Singleton::getInstance(); sp-\u0026gt;run(); }  使用C++11的shared_ptr方式，自动释放懒汉模式内存。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; #include \u0026lt;mutex\u0026gt; using std::cout; using std::endl; using std::shared_ptr; using std::mutex; using std::lock_guard; class Singleton{ public: static shared_ptr\u0026lt;Singleton\u0026gt; getInstance(){ if(_instance == nullptr) { lock_guard\u0026lt;mutex\u0026gt; lock(m_mutex); if(_instance == nullptr) { _instance.reset(new Singleton(), destroy); } } return _instance; } void run() { std::cout \u0026lt;\u0026lt; \u0026quot;run\u0026quot; \u0026lt;\u0026lt; std::endl; } private: Singleton(){ cout \u0026lt;\u0026lt; \u0026quot;Constructor\u0026quot; \u0026lt;\u0026lt; endl; } ~Singleton(){ cout \u0026lt;\u0026lt; \u0026quot;Deconstructor\u0026quot; \u0026lt;\u0026lt; endl; } Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp; )=delete; static void destroy(Singleton* p){ if(p) { delete p; cout \u0026lt;\u0026lt; \u0026quot;delete instance\u0026quot; \u0026lt;\u0026lt; endl; } } static shared_ptr\u0026lt;Singleton\u0026gt; _instance; static mutex m_mutex; }; shared_ptr\u0026lt;Singleton\u0026gt; Singleton::_instance(nullptr); mutex Singleton::m_mutex; int main() { shared_ptr\u0026lt;Singleton\u0026gt; sp = Singleton::getInstance(); sp-\u0026gt;run(); }  ","id":1,"section":"posts","summary":"饿汉模式 在程序开始时就完成实例化操作。 #include \u0026lt;iostream\u0026gt; #include \u0026lt;memory\u0026gt; class Singleton { private: Singleton(){ std::cout \u0026lt;\u0026lt; \u0026quot;Constructor\u0026quot; \u0026lt;\u0026lt; std::endl; } ~Singleton() { std::cout \u0026lt;\u0026lt; \u0026quot;Deconstructor\u0026quot; \u0026lt;\u0026lt; std::endl; } Singleton(const Singleton\u0026amp;)=delete; Singleton\u0026amp; operator=(const Singleton\u0026amp;)=delete; static Singleton m_instance; public: static Singleton* getInstance() { return \u0026amp;m_instance; } void echo() { std::cout \u0026lt;\u0026lt; \u0026quot;Print All Message.\u0026quot; \u0026lt;\u0026lt; std::endl; } };","tags":["设计模式","c/c++"],"title":"设计模式-单例模式","uri":"https://ketop.github.io/2021/04/singleton/","year":"2021"},{"content":"windows wsl可以很方便的让我们在win10中运行各种发行版的linux。但是在使用wsl之后，我安装了很多软件，直接导致在wsl ubuntu中再使用apt来安装软件后，C盘直接变红了。\n解决办法 在网上查找资料，使用LxRunOffline,可以将wsl从C盘转移到其他盘。果断使用起来。\n 下载LxRunOffline LxRunOffline 查看当前wsl的发行版  ./LxRunOffline l Ubuntu  移动到D盘wsl目录中  .\\LxRunOffline move -n Debain -d D:\\wsl  经过以上操作后，C盘终于回蓝，同时D盘多了wsl目录。\n日常问题  可能系统重新开机后，ubuntu子系统打不开 解决办法：管理员用户打开powershell  netsh winsock reset  ","id":2,"section":"posts","summary":"windows wsl可以很方便的让我们在win10中运行各种发行版的linux。但是在使用wsl之后，我安装了很多软件，直接导致在wsl ubuntu中再","tags":["wsl"],"title":"win10 wsl","uri":"https://ketop.github.io/2021/01/wsl/","year":"2021"},{"content":"c++11之前的可调用对象有：函数，函数指针，以及重载operator()运算符的对象。C++11之后，新增了可调用对象lambda表达式和bind函数的返回值，同时引入了新的类型function，用来统一可调用对象。声明方式如下\nfunction\u0026lt;T\u0026gt;;  T表示函数类型，ret-type(paramlist). 例如function\u0026lt;int(int,int)\u0026gt;表示返回值为int，入参为int，int的函数类型。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;string\u0026gt; using std::string; using std::function; //普通函数 size_t func(const string\u0026amp; a){ std::cout \u0026lt;\u0026lt; \u0026quot;func:\u0026quot; \u0026lt;\u0026lt; std::endl; return a.size(); } //函数指针 size_t (*funcp)(const string\u0026amp; a) = func; //类重载了operator()运算符，即对象的行为跟函数一样，除此之外，也可以包含其他成员 struct FuncA { FuncA():name(\u0026quot;default instance\u0026quot;){} size_t operator()(const string\u0026amp;a){ std::cout \u0026lt;\u0026lt; \u0026quot;FuncA instance \u0026quot; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026quot;'s operator()\u0026quot; \u0026lt;\u0026lt; std::endl; return a.size(); } string name; }; int main() { //使用funciton来统一调用 std::function\u0026lt;size_t(const string\u0026amp;)\u0026gt; mofun; mofun = func; string cs(\u0026quot;nice ok\u0026quot;); std::cout \u0026lt;\u0026lt; mofun(cs)\u0026lt;\u0026lt; std::endl; mofun = funcp; std::cout \u0026lt;\u0026lt; mofun(cs)\u0026lt;\u0026lt; std::endl; mofun = [](const string\u0026amp; a)-\u0026gt;size_t { std::cout \u0026lt;\u0026lt; \u0026quot;lambda:\u0026quot; \u0026lt;\u0026lt; std::endl; return a.size(); }; string az(\u0026quot;nice to see you\u0026quot;); std::cout \u0026lt;\u0026lt; mofun(az) \u0026lt;\u0026lt; std::endl; mofun = FuncA();//创建了一个FuncA类型的临时对象，等价于 // FuncA tmp; // mofun = tmp; std::cout \u0026lt;\u0026lt; mofun(az) \u0026lt;\u0026lt; std::endl; return 0; }  ·除此之外，还有bind，它也在functional头文件中。可以将其视作函数适配器，用来对原函数进行形参位置、个数调整从而产生新的可调用对象。调用形式如下：\nauto newCallable=bind(callable, args_list)  args_list可能包含形如_n的名字，这些参数都是指占位符，数字n表示 新的可调用对象中的参数位置，从1开始。\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;functional\u0026gt; #include \u0026lt;string\u0026gt; using std::string; void funN(const string\u0026amp;a, const string\u0026amp;b) { swap(a,b); std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; std::endl; } int main(){ string az(\u0026quot;Love\u0026quot;); string cs(\u0026quot;You\u0026quot;); funN(az, cs); std::function\u0026lt;int(int,int)\u0026gt; func; auto newCallable = bind(funN, std::placeholders::_2, std::placeholders::_1); newCallable(az, cs); //修改入参个数 auto onlyOne = bind(funN, az, std::placeholders::_1); string c(\u0026quot;world\u0026quot;); onlyOne(c); //如果bind中使用的是引用类型变量，必须加上std::ref,否则函数使用的是右值，不改变原有值 std::cout \u0026lt;\u0026lt; \u0026quot;az: \u0026quot; \u0026lt;\u0026lt; az \u0026lt;\u0026lt; \u0026quot;, c: \u0026quot; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; std::endl;//az并不变,但是c变了 //使用std::ref即可 onlyOne2 = bind(funN, std::ref(az), std::placeholders::_1); c=\u0026quot;world\u0026quot;; onlyOne2(c); //如果bind中使用的是引用类型变量，必须加上std::ref,否则函数使用的是右值，不改变原有值 std::cout \u0026lt;\u0026lt; \u0026quot;az: \u0026quot; \u0026lt;\u0026lt; az \u0026lt;\u0026lt; \u0026quot;, c: \u0026quot; \u0026lt;\u0026lt; c \u0026lt;\u0026lt; std::endl;//az也改变,c也变了 return 0; }  ","id":3,"section":"posts","summary":"c++11之前的可调用对象有：函数，函数指针，以及重载operator()运算符的对象。C++11之后，新增了可调用对象lambda表达式和","tags":["c/c++"],"title":"C++可调用对象","uri":"https://ketop.github.io/2020/12/callable/","year":"2020"},{"content":"hugo博客使用方法  使用hugo new site命令来生成博客站点的目录结构 在themes目录下安装自己喜欢的主题，例如我这里的Pure 拷贝主题下的toml或者yml的配置文件到站点目录下 自定义config.toml或者config.yml中的内容 在content目录下的posts中写自己的markdown博客 需要使用hugo命令来生成public目录 将public推送到github某个分支  可以看到，每次写完文章后，需要在本地执行hugo命令，然后推送到github，覆盖某个branch，非常麻烦。之前使用jekyll博客都是直接推送到github上就行了，github自动帮我们编译。\nhugo博客要做到这点，就必须要自动化完成步骤6和7，那么该怎么能自动化呢？答案是 Travis-CI\ntravis ci使用方法  使用github账号登陆travis 选择ketop.github.io的仓库，travis将监听该仓库的动态 在该项目代码中新增.travis.yml文件，用于定义travis任务  language: go go: - 1.8 branches: only: - master install: #下载并安装hugo - wget https://github.com/gohugoio/hugo/releases/download/v0.74.3/hugo_0.74.3_Linux-64bit.deb - sudo dpkg -i hugo*.deb script: - hugo deploy: provider: pages skip-cleanup: true local-dir: public target-branch: hugo github-token: $GITHUB_TOKEN # 设置token用于推送public目录到仓库的ketop.github.io keep-history: true on: branch: master  这样设置后，每次向master中推送新的post后，会触发travis任务。该任务完成以下步骤\n 下载hugo的deb包，并使用dpkg命令安装 使用hugo来编译生成public目录 deploy中的povider:pages表示部署为github pages。将public目录推送到hugo分支。  当任务完成后，刷新ketop.github.io就可以看到更新的博客了，效果已经和github的jekyll很像了。\n","id":4,"section":"posts","summary":"hugo博客使用方法 使用hugo new site命令来生成博客站点的目录结构 在themes目录下安装自己喜欢的主题，例如我这里的Pure 拷贝主题下","tags":["travis-ci","github","hugo"],"title":"使用travis ci自动化发布hugo博客","uri":"https://ketop.github.io/2020/09/2020-09-17-travis-ci/","year":"2020"},{"content":"终于又从Archlinux切换到了Ubuntu 18.04 LTS. 原因是发现archlinux确实不稳定，每次滚动升级概率性出现桌面无法启动的现象。\n那么这次安装Ubuntu的体验是什么呢？\nProblems：\n 安装Ubuntu时，在分区的时候，如果没有手动建EFI分区，会提示要新建。 这次终于看清楚了，原来以前Ubuntu总是装不上，就是因为我忽略了这个提示，然后后面安装grub的时候死活装不上。这次在CSDN的某个博主的文章下好好看了这个问题。在新建EFI分区后，成功了。 安装vim插件youcompleteme时，发现现在插件的仓库名变成了\u0026rsquo;ycm-core/YouCompleteMe' 这个插件需要下载很多github上的release制品，但是又下不下来（github网站上下载制品特别慢).然后在知乎上看到了一个救星，通过一个网站将所需要的文件下载下来，然后它会给我提供几个下载地址, 这些速度极快，简直不要太爽。附上链接： https://d.serctl.com/ gnome桌面确实臃肿，但是架不住它可定制能力强啊！看到了McMojave这个主题，真的把持不住了。附上链接: https://www.gnome-look.org/p/1275087/  成就：\n 重新搭建了Linux开发环境，应该说vim开发环境 ubuntu现在美化成了MacOS。  附上效果图： ","id":5,"section":"posts","summary":"终于又从Archlinux切换到了Ubuntu 18.04 LTS. 原因是发现archlinux确实不稳定，每次滚动升级概率性出现桌面无法启动的现象。 那么这次","tags":["ubuntu"],"title":"Ubuntu 18.04 LTS美化配置","uri":"https://ketop.github.io/2020/04/2020-04-05-helloubuntu/","year":"2020"},{"content":"实例化一个类有两种方式\n 静态实例化。编译器自动在栈上分配内存，然后调用构造函数。实例对象离开所在作用域后，执行析构函数，然后由编译器自动回收栈的内存。编译器会根据类的构造函数和析构函数的可访问性来判断是否可以在栈上实例化。 动态实例化。程序员编码使用new操作符来实例化对象。new操作符调用类的operator new来在堆上申请内存，如果没有自定义的operator new，则调用全局的operator new来申请内存，然后使用定位new，调用类的构造函数。动态实例化对象，需要程序员自己调用delete来销毁对象。同理，在调用delete操作符时，会使用类的析构函数，然后使用类的operator delete来释放内存。如果没有定义类的operator delete，则使用全局的operator delete来释放内存。编译器会根据operator new和operator delete的可访问性来判断是否可以在栈上构造。  //静态实例化 Object o; //动态实例化 Object * po = new Object;  综上所述，如果需要限制类对象仅在栈上实例化，也就是禁止调用new来实例化对象，则可以将类的operator new和operator delete 设为delete.\n#include \u0026lt;iostream\u0026gt; class OnlyStack { private: char* sentence; public: void* operator new(size_t ) = delete; void operator delete(void* ptr) = delete; OnlyStack() { std::cout \u0026lt;\u0026lt; \u0026quot;initial ...\u0026quot; \u0026lt;\u0026lt; std::endl; sentence = new char[10]; for(int i = 0; i \u0026lt; 9; i++){ sentence[i]= 'a' + i; } sentence[9]='\\0'; } ~OnlyStack() { std::cout \u0026lt;\u0026lt; \u0026quot;destroy ...\u0026quot; \u0026lt;\u0026lt; std::endl; delete sentence; } void printSentence() { std::cout \u0026lt;\u0026lt; sentence \u0026lt;\u0026lt; std::endl; } }; int main(){ //OnlyStack* osk = new OnlyStack; //无法使用new来实例化对象 OnlyStack osk; osk.printSentence(); }  如果需要限制类对象仅在堆上实例化，也就是禁止直接调用构造函数来在栈上实例化，最直接的方式就是将类的构造函数设置为私有的。但是这种方式就需要类提供public的构建函数（例如单例的getInstance()),在函数中调用new操作符来实例化对象。 但是局限性在于，在类外不能使用new来实例化。\n#include \u0026lt;iostream\u0026gt; class OnlyHeap { private: char* sentence; OnlyHeap() { std::cout \u0026lt;\u0026lt; \u0026quot;initial ...\u0026quot; \u0026lt;\u0026lt; std::endl; sentence = new char[10]; for(int i = 0; i \u0026lt; 9; i++){ sentence[i]= 'a' + i; } sentence[9]='\\0'; } public: static OnlyHeap* create() { return new OnlyHeap(); } static void destroy(OnlyHeap* ptr){ delete ptr; } ~OnlyHeap() { std::cout \u0026lt;\u0026lt; \u0026quot;destroy ...\u0026quot; \u0026lt;\u0026lt; std::endl; delete sentence; } void printSentence() { std::cout \u0026lt;\u0026lt; sentence \u0026lt;\u0026lt; std::endl; } }; int main(){ OnlyHeap* ohp = OnlyHeap::create();//无法直接调用new来类外创建对象。 ohp-\u0026gt;printSentence(); delete ohp; //OnlyHeap::destroy(ohp); //如果析构函数也声明为私有的，则可以使用此函数来释放对象内存。 }  因此可以考虑将类的析构函数设置为私有的。\n#include \u0026lt;iostream\u0026gt; class OnlyHeap { private: char* sentence; ~OnlyHeap() { std::cout \u0026lt;\u0026lt; \u0026quot;destroy ...\u0026quot; \u0026lt;\u0026lt; std::endl; delete sentence; } public: static OnlyHeap* create() { return new OnlyHeap(); } static void destroy(OnlyHeap* ptr){ delete ptr; } void destory_self(){ delete this; } OnlyHeap() { std::cout \u0026lt;\u0026lt; \u0026quot;initial ...\u0026quot; \u0026lt;\u0026lt; std::endl; sentence = new char[10]; for(int i = 0; i \u0026lt; 9; i++){ sentence[i]= 'a' + i; } sentence[9]='\\0'; } void printSentence() { std::cout \u0026lt;\u0026lt; sentence \u0026lt;\u0026lt; std::endl; } }; int main(){ OnlyHeap* ohp = new OnlyHeap(); ohp-\u0026gt;printSentence(); ohp-\u0026gt;destory_self();//无法直接调用delete ohp来释放内存,析构函数定义为私有的了。 }  ","id":6,"section":"posts","summary":"实例化一个类有两种方式 静态实例化。编译器自动在栈上分配内存，然后调用构造函数。实例对象离开所在作用域后，执行析构函数，然后由编译器自动回收栈","tags":["c/c++"],"title":"C++控制类对象实例化仅在栈或者堆上的方法","uri":"https://ketop.github.io/2019/04/cpp_instance/","year":"2019"},{"content":"当定义一个类时， 我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些对象， 包括：\n 拷贝构造函数 拷贝赋值运算符 移动构造函数 移动赋值运算符 析构函数  拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么；拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么；析构函数定义了当此类型对象销毁时做什么。我们称这些操作为拷贝控制操作。\n拷贝构造函数 class Foo { public: Foo(); //默认构造函数 Foo(const Foo\u0026amp;);// 拷贝构造函数 //... }; /* * 拷贝构造函数的第一个参数几乎总是一个自身类型的const引用 * 拷贝构造函数在几种情况下都会被隐式地使用，因此构造函数 * 通常不应该是explicity的 */  合成拷贝构造函数 如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同， 即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。 一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定的对象中依次将每个非static成员拷贝到正在创建的对象中。 每个成员的类型决定了它如何拷贝: 对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。对于数组成员，合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素为类类型，则使用元素的拷贝构造函数来进行拷贝。\nclass Sales_data { public: //其他成员和构造函数的定义，与以前一致 //与合成拷贝构造函数等价的拷贝构造函数 Sales_data(const Sales_data \u0026amp;); private: std::string bookNo; unsigned units_sold - 0; double revenue = 0.0; }; //与合成的拷贝构造函数等价的拷贝构造函数 Sales_data::Sales_data(const Sales_data \u0026amp;orig): bookNo(orig.bookNo), units_sold(orig.units_sold), revenue(orig.revenue) { // empty }  拷贝初始化与值初始化的区别\nstring dots(1o, '.');//直接初始化 string s(dots);//直接初始化 string s2 = dots;//拷贝初始化 string null_book = \u0026quot;9-999-99999-9\u0026quot;;//拷贝初始化 string nines = string(100, '9');//拷贝初始化  当使用直接初始化时，实际上是编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当使用拷贝初始化时，我们要求将右侧运算对象拷贝到正在创建的对象中，如果需要的话将进行类型转换。 拷贝初始化通常使用拷贝构造函数来完成。但是，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。\n拷贝初始化不仅在我们用=定义变量时会发生，下列情况也会发生 • 将一个对象作为实参传递给一个非引用类型的形参 • 从一个返回类型为非引用类型的函数返回一个对象 • 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。 • 某些类类型会对它们所分配的对象使用拷贝初始化。例如初始化标准容器或是调用其insert和push成员事，容器会对其元素进行拷贝初始化，与之相对的，用emplace成员创建的元素都进行直接初始化。\n拷贝赋值运算符 class Foo { public: Foo\u0026amp; operator=(const Foo \u0026amp;);//赋值运算符 //.. };  合成拷贝赋值运算符 与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。通常情况下，它将右侧运算对象的每个非static成员赋予左侧运算对象对应的成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。\n/*等价于合成拷贝赋值运算符*/ Sales_data\u0026amp; Sales_data::operator=(const Sales_data \u0026amp;rhs) { bookNo = rhs.bookNo; //调用string::operator= units_sold = rhs.units_sold;//内置的int赋值 revenue = rhs.revenue;//内置的double赋值 return *this; }  析构函数 析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。\nclass Foo { public: ~Foo();//析构函数 //... };  析构函数没有返回值，也不接受参数。由于析构函数不接受参数，因此它不能被重载。对于一个给定类，只有唯一一个析构函数。 在一个构造函数中，成员初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。 在对象最后一次使用后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存期分配的所有资源。在析构函数中不存在类似于构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁时完全以来于成员的类型。销毁类类型成员会执行其对应的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。与普通指针不同，智能指针是类类型，所以具有析构函数，因此与普通指针不同，智能指针成员在析构阶段会被自动销毁。\n析构函数在对象被销毁时自动调用。 • 变量离开其作用域时被销毁 • 当一个对象被销毁时，其成员被销毁 • 容器（无论是标准容器还是数组）被销毁时，其元素被销毁 • 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁 • 对于临时对象，当创建它的完整表达式结束时被销毁\n合成析构函数 当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。通常情况下，合成的析构函数体为空。对于某些类，合成析构函数被用来阻止该类型的对象被销毁。析构函数体自身并不直接销毁成员，成员是在函数体执行之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。\n","id":7,"section":"posts","summary":"当定义一个类时， 我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些对象， 包括： 拷","tags":["c/c++"],"title":"C++拷贝构造函数","uri":"https://ketop.github.io/2018/08/2020-04-05-c-%E8%AF%AD%E6%B3%952/","year":"2018"},{"content":"为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是拷贝资源，\n移动构造函数 移动构造函数的第一个参数是该类型的一个右值引用，类似于拷贝构造函数，任何额外的参数都必须有默认实参。 除完成资源移动，移动构造函数还必须确保移后源处于这样一种状态：销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源\u0026ndash;这些资源的所有权已经归属新创建的对象。\nclass StrVec { public: StrVec(): elements(nullptr), first_free(nullptr), cap(nullptr) {} StrVec(const StrVec\u0026amp;); StrVec \u0026amp;operator=(const StrVec\u0026amp;); StrVec(StrVec \u0026amp;\u0026amp;) noexcept; StrVec\u0026amp; operator=(StrVec \u0026amp;\u0026amp;) noexcept; ~StrVec(); //.... private: static std::allocator\u0026lt;std::string\u0026gt; alloc; void chk_n_alloc() {if(size() == capacity()) reallocate(); } std::pair\u0026lt;std::string*, std::string*\u0026gt;alloc_n_copy (const std::string*, const std::string*); void free(); void reallocate(); std::string *elements; std::string *first_free; std::string *cap; }; StrVec::StrVec(StrVec \u0026amp;\u0026amp;s) noexcept : elements(s.elements), first_free(s.first_free), cap(s.cap) { s.elements = s.first_free = s.cap = nullptr; }  与拷贝构造函数不同，移动构造函数不分配任何新内存；它接管给定的strVec中的内存。在接管内存后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。 StrVec的析构函数在first_free上调用deallocate.如果我们忘了改变s.first_free,则销毁移后源对象就会释放掉我们刚刚移动的内存。\n由于移动操作“窃取”资源，它通常不分配仍和资源。因此，移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库。默认的标准库会认为移动我们的类对象时可能抛出异常，而且会为了处理这种可能性而做一些额外的工作。\n通知标准库的方法是在构造函数中指明noexcept。在一个构造函数中，noexcept出现在参数列表和初始化列表开始的冒号之间。我们必须在类的头文件的声明和定义中都指定noexcept。 不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept.\n合成的移动操作 与拷贝构造函数不同，编译器根本不会为某些类合成移动操作。特别的，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。\n只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个static数据成员都可以移动时，编译器才会合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员；如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。\n与拷贝操作不同， 移动操作永远不会隐式定义为删除的函数。但是如果我们要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。 除了一个重要的例外，什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则。 • 移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数；或者有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符类似 • 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的 • 类似拷贝构造函数，如果类的析构函数被定义为删除的或者不可访问的，则类的移动构造函数被定义为删除的。 • 类似拷贝赋值运算符，如果有类成员是const的或引用， 则类的移动赋值运算符被定义为删除的。\n移动操作和合成的拷贝控制成员还有最后一个相互作用的关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。 即定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则，这些成员默认地被定义为删除的。\n当一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪种构造函数。赋值操作的情况类似。 如果没有移动构造函数，右值也被拷贝。即使我们试图通过调用move来移动它们。\nclass Foo { public: Foo() = default; Foo(const Foo\u0026amp;); //其他成员定义， 但Foo未定义移动构造函数 }; Foo x; Foo y(x); //拷贝构造函数；x是一个左值 Foo z(std::move(x));//拷贝构造函数，因未定义移动构造函数  实际上std::move(x)返回 Foo \u0026amp;\u0026amp;， 我们可以将Foo\u0026amp;\u0026amp;转换为const Foo\u0026amp;.因此z的初始化将使用Foo的拷贝构造函数。值得注意的是，使用拷贝构造函数替代移动构造函数几乎肯定是安全的。一般情况下，拷贝构造函数满足对应的移动构造函数的要求：它会拷贝给定对象，并将原对象置于有效状态。实际上，拷贝构造函数甚至不会改变原对象的值。\n拷贝并交换赋值运算符和移动操作\nclass HasPtr { public: /*添加的移动构造函数*/ HasPtr(HasPtr \u0026amp;\u0026amp;p) noexcept: ps(p.ps), i(p.i) {p.ps = 0;} /*赋值运算符既是移动赋值运算符，也是拷贝赋值运算符*/ HasPtr\u0026amp; operator=(HasPtr rhs){swap(*this, rhs); return *this;} };  更新三/五法则 所有的五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外的开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。\n建议 只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能使用移动操作。 由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。 通过在类代码中小心地使用move，可以大幅提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提升应用程序性能。\n","id":8,"section":"posts","summary":"为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是","tags":["c/c++"],"title":"C++移动构造函数","uri":"https://ketop.github.io/2018/08/2020-04-05-c-%E8%AF%AD%E6%B3%95/","year":"2018"},{"content":"TCP/IP的心脏是互联网层。该层主要由IP协议与ICMP(Internet Control Message Protocol)两个协议组成。\nIP协议 IP相当与OSI模型中的第3层网络层。网络层的主要作用是“实现终端节点之间的通信”。数据链路层的主要作用是在互连的同一种数据链路的节点之间进行包传递。而一旦跨越多种数据链路，就需要借助网络层。网络层可以跨越不同的数据链路，即使是在不同的数据链路上也能实现两端点之间的数据包传输。\nIP基础知识   数据链路有MAC地址，网络层使用IP地址。IP地址用于在“连接到网络中的所有主机中识别出进行通信的目标地址”。因此在TCP/IP通信中所有的主机或者路由器必须设定自己的IP地址。IP地址与数据链路没有关系，任何数据链路形式的改变都不会影响IP地址的形式。在网桥、交换集线器等物理层与数据链路层数据包转发设备中，不需要设置IP地址。\n  路由控制 将分组数据发送到最终目标地址的功能。即使网络非常复杂，也可以通过路由控制u确定到达目标地址的通路。路由控制如果出现异常，分组数据极有可能“迷失”。因此，一个数据包之所以能成功到达最终的目标地址，全靠路由控制。\n   Hop译为“跳”。它是指网络中的一个区间。该区间指利用数据链路层一下分层的功能传输数据帧的一个区间。这个区间是主机或者路由器网卡不经过其他路由器而能直接到达的相邻的主机或路由器网卡之间的一个区间。在这一跳中，可以有网桥或者交换集线器相连，但不会通过路由器或网关相连。\n   路由控制表 为了将数据包发给目标主机，所有的主机都维护这一张路由控制表。该表记录IP数据在下一步应该发个哪个路由器。IP包将根据这个路由表在各个数据链路上传输。\n  数据链路的抽象化 对不同数据链路的相异特征进行抽象化也是IP的重要作用之一。不同的数据链路有个最大的区别，就是它们各自的最大传输单位(MTU: Maximum Transmission Unit)不同。MTU在以太网中为1500Bytes，FDDI为4352Bytes，ATM则为9180Bytes。IP的上一层可能会要求传送比这些MTU更多的字节，因此必须在线路上传送比包长还小的MTU。\n   为了解决这个问题，IP进行分片处理。将较大的IP包分为多个较小的IP包。分片的包到了对端目标地址以后会再被组合起来传送给上一层。从上一层来看，它完全忽略这个分包过程。IP使用这种方式抽象了数据链路层。\n  IP属于面向无连接型 是否面向连接交给上层协议来决定，IP采用面向无连接的方式。一是为了简化，二是为了提速。  IP地址的定义 192.168.1.119 ---.---.---.--- (网络标识)(主机标识)  网络标识在数据链路的每个段配置不同的值。网络标识必须保证相互连接的每个段的地址不重复。而相同段内的主机必须有相同的网络地址，但主机标识不能重复。\nIP包被转发到途中某个路由器时，是利用IP地址的网络标识进行路由。因为即使看不到主机标识，只要一见到网络标识就能判断出是否为该段内主机。\n到底前几位为网络标识，现在基本以子网掩码(网络前缀)区分。以前是通过分类来区分的(A/B/C/D).\n   分类 特点     A类 首位为“0”，第1位到第8位为网络标识，后24位相当于主机标识   B类 以“10”开头，第1到第16位为网络标识   C类 以“110”开头，第1位到第24位为网络标识   D类 以“1110”开头，从第1位到32位为网络标识    广播地址 用于在同一个链路中相互连接的主机之间发送数据包。将IP地址中的主机地址部分全部设置为1，就成为了广播地址。\n  本地广播 仅在本网络内进行广播，由于该广播地址的IP包会被路由器屏蔽，所以不会到达本网络之外的其他链路。 直接广播 在不同的网络之间的广播。收到这个包的路由器将数据转发到其他网络段。这种广播有一定的安全问题。多数情况下会在路由器上设置为不转发。   多播地址用于将包发送给特定组内的所有主机。由于其直接使用IP协议，因此不是可靠传输。在多媒体应用中使用广泛，具体实现上往往采用复制1对1通信的数据，将其同时发送给多个主机的方式。多播即可以穿透路由器，也可以实现只给那些必要的组发送数据包。\n 多播地址使用D类地址，如果首位开始到第4位为“1110”，就可以认为是多播地址。而剩下的28位可以成为多播的组编号。从224.0.0.0到239.255.255.255都是多播地址的可用范围。其中从224.0,0.0到224.0.0.255的范围不需要路由器控制，在同一个链路内也能实现多播。而在这个范围之外设置多播地址会给全网所有组内成员发送多播的包。\n  此外，对于多播，所有的主机(路由器以外的主机和终端主机)必须属于224.0.0.1的组，所有的路由器必须属于224.0.0.2的组。\n 子网掩码\n对应于网络标识的位全为1,主机标识全为0.\n另外一种表示方法是在IP地址后追加网络地址的位数，用“/”隔开。这种方式可以省略IP地址后面的0,例如172.20.0.0/16跟172.20/16其实是一个意思。\nIP协议相关技术 IP协议继续要为上层服务，也需要下层数据链路层的支持。在实际中，仅凭IP远远不够，还需要众多支持IP的相关技术。\n DNS   IP地址由一串数字序列组成，并不好记。为此TCP/IP世界中有了主机识别码的东西。系统会自动进行主机名转换为具体IP的过程。然而，随着网络规模的扩大，需要有效管理这些对应关系。因此就有了DNS(Domain Name System)。\n  域名由几个英文字母用点号连接构成。DNS采用分层管理，看起来像一棵倒挂的树，称为树形结构。\n  域名服务器是指管理域名的主机和相应的软件，它可以管理所在分层的域的相关信息。所管理的分层叫做ZONE。每层都设有一个域名服务器。各层域名服务器都了解该层以下分层中所有的域名服务器的IP地址。因此它们从根域名服务器开始呈树状结构相互连接。 由于所有域名服务器都了解根域名服务器的IP地址，所以若从根开始按追踪，可以访问世界上所有域名服务器的地址。下层的变更需要在上层进行相应的修改变更。\n  进行DNS查询的主机和软件叫做DNS解析器。一个解析器至少要注册一个以上域名服务器的IP地址。通常，它至少包括组织内部的域名服务器的IP地址。\n  ARP   在确定IP地址之后，实际通信还需要MAC地址。ARP(Address Resolution Protocol)是一种解决问题的协议。以目标IP为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。如果目标主机不在同一个链路上，可以通过ARP查找下一跳路由器的MAC地址。\n  首先在同链路内广播ARP请求包，该请求包将被同一个链路上的所有的主机或路由器接收，因此ARP请求包也就会被这同一个链路中的所有主机和路由器进行解析。如果本链路内找到目标主机，则该节点会将自己的MAC地址塞入ARP响应包返回给主机A。在不同链路中传输，会现将请求包发送给链路内的路由器，此时响应包中的MAC地址为该路由器的MAC地址。\n  ICMP   ICMP的主要功能包括，确认IP包是否成功送达目标地址，通知在发送过程中IP包被废弃的具体原因，改善网络设置等。 ICMP的这种通知消息会使用IP进行发送。ICMP的消息大致可以分为两类:一类是通知出错原因的错误消息，另一类是用于诊断的查询信息。\n  DHCP   一般电脑入网前，需要手动设置IP地址、子网掩码、默认路由及DNS服务器等。为了实现自动设置IP地址、统一管理IP地址分配，就产生了DHCP(Dynamic Host Configuration Protocol)协议。有了DHCP，计算机只要连接到网络，就可以进行TCP/IP通信。DHCP额昂即插即用变为可能。\n  DHCP在工作时，首先客户端向链路内广播DHCP发现包，发现包的目标地址为广播地址255.255.255.255，而源地址则为0.0.0.0。然后DHCP给客户端发送DHCP提供包，通知可以使用的网络设置。DHCP客户端再次发送DHCP请求包，表示想使用DHCP服务器响应包中的设置。最后DHCP服务器返回DHCP提供包，通知客户端被允许使用该设置。\n  NAT(Network Address Translator)   用于在本地网络中使用私有地址，在链接互联网时转而使用全局IP地址的技术。除转换IP地址外，还出现了可以转换TCP、UDP端口号的NAPT(Network Address Ports Translator)技术，由此可以实现用一个全局IP地址与多个主机的通信。 通常所说的NAT指的就是NAPT。\n  NAT路由器将内网IP包的IP首部进行转换，转换为全局IP首部进行转发。当有包从互联网传入时，也需要进行IP首部替换，改变为私有IP地址，然后再进行转发。在NAT(NAPT)路由器内部，会自动生成一张用来转换的表，然后按表中的映射关系进行处理。\n  NAT仅仅转换IP地址，实际上只能同时有一台主机能完成通信。NAPT是将IP和端口号一起转换，将不同的内网IP转换为相同主机不同端口，从而实现与互联网的通信。\n  NAT(NAPT)都依赖于自己的转换表。但转换表只在内网向外网发包时才创建映射，因此无法从NAT外部向内部发起连接。 转换表的生成和转换需要一定的开销。通信过程中一旦NAT异常需要重新启动，所有的TCP连接将被重置。即使有两台NAT做容灾备份，TCP连接还是会断开。\n  IP隧道   如果网络A、B使用IPv6,而中间位置的网络C使用的IPv4的话，网络A与网络B将无法直接进行通信。为了让它们之间正常的通信，必须采用IP隧道的知识。\n  IP隧道中将那些从网络A发送过来的IPv6的包统一为一个数据，在为之加上IPv4的首部以后转发给网络C。一般的情况下，IP首部之后是TCP或UDP的首部，现在紧接着还是IP首部，这种情况与日俱增，被称为\u0026quot;IP隧道\u0026quot;。 例如，现在很多路由器上没有多播包的路由控制信息，多播消息也就无法穿越路由器发送的消息，那么在这类环境中，可以使用IP隧道，就可以使路由器用单播的形式发包，也就能够想距离较远的链路转发多播消息。 实际的应用还有\n Mobile IP 多播包的转播 IPv4网络中传送IPv6的包 IPv6网络中传送IPv4的包 数据链路帧通过IP包发送(L2TP)    IP多播相关技术  IP任播 通信质量控制 -显式阻塞通知 Mobile IP    ","id":9,"section":"posts","summary":"TCP/IP的心脏是互联网层。该层主要由IP协议与ICMP(Internet Control Message Protocol)两个协议组成。 IP协议 IP相当与OSI模型","tags":["tcp/ip","网络"],"title":"IP协议","uri":"https://ketop.github.io/2018/08/internet03/","year":"2018"},{"content":"TCP是面向连接的协议，它提供持续可交付的可靠连接。充分实现了数据传输时的各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行顺序控制。TCP只有在确认通信对端存在时才会发送数据，从而可以控制通信流量的浪费。\n 通过序列号与确认应答提高可靠性。 当发送端的数据到达主机时，接收端主机会返回一个已收到消息的通知，该消息称为确认应答(ACK)。   如果收到了ACK，表示数据已经成功送达。当没有收到ACK时，有可能是数据丢失，或者ACK在返回时丢失，此外还有可能是因为其他原因而延迟到达。 这时，主机可能会重发数据。这种重发机制能保证数据不丢失。但是，如果数据已经到达，只是ACK没有接收到，则重发会给接收端带来负担。它需要一种机制，使接收端识别是否已经收到数据，又能判断是否需要接收。\n  这些需要的功能可以通过序列号实现。序列号是按顺序给发送数据的每个字节都标上号码的编号。接收端查询接收数据TCP首部的序列号和数据长度，将自己下一步应该接收的序号作为确认应答返送回去。这样通过序列号和确认应答号，TCP可以实现可靠传输。\n  重发超时的确定。 重发超时是指在重发数据之前，等待确认应答到来的那个特定时间间隔。如果超过了指定时间仍未收到确认应答，发送端将进行数据重发。 TCP在每次发包时，会计算往返时间及其偏差。   往返时间，指报文段的往返时间。 Round Trip Time, RTT。\n  偏差， RTT时间波动的值、方差。有时也称抖动。一般设置的重发超时 时间以0.5s为单位，是其整数倍。偏差的最小值也是0.5,因此最小的重发时间为1s。初始通信的重发超时时间为6s。如果重发后仍没有ACK，则进行再次发送，此时，等待确认应答时间将会以2倍、4倍的指数函数延长。在达到一定重发次数后，如果仍未回应，则会判断为网络对端主机发生了异常，强制关闭连接，并通知应用程序异常强行终止。\n  连接管理  (三次握手)\n 客户端发送连接请求SYN 服务端发送ACK，以及SYN允许 客户端对服务端发送ACK表示成功连接  (断开连接)\n 客户端发送FIN，请求切断连接 服务端发送FIN的ACK应答 服务端发送FIN给客户端 客户端向服务端发送ACK  综上知，一个连接的建立和断开的正常过程至少需要7个包才能完成。\n TCP以段为单位发送数据 在建立TCP连接的同时，也可以确定发送数据包的单位。称为MSS(Maximum Segment Size).最理想情况下，最大消息长度正好是IP中不会被分片处理的最大数据长度。  TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。进行重发时以MSS为单位。\nMSS是在三次握手的时候，在两端主机之间被计算得出。两端主机在发出建立连接的请求时，会在TCP首部中写入MSS选项，告诉对方的接口能够适应的MSS的大小。然后在传输数据时选择二者之间较小的一个。\n 利用窗口控制提高速度。每发一个段进行一次确认应答，然后再发送下一段，这种方式的缺点是，包往返的时间越长，网络的吞吐量会越差。为解决这个问题，TCP引入窗口概念。   确认应答不再每段返回一次，而是以更大的单位进行确认，这样转发时间将会被大幅度地缩短。 窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。该机制的实现使用了大量的缓冲区，通过多个段同时进行确认应答的功能。\n  如果没有达到数据窗口最大值就有确认应答返回，则说明存在数据在传输中丢失的情况。这种情况将进行重发。为此，发送端主机在等到确认应答返回之前，必须在缓冲区中保留这部分数据。\n   窗口控制与重发控制。 当数据已经被接收，但是没有收到ACK时，可以通过之后的ACK来确认数据已经收到。但是当某些数据没有被接收而导致的ACK没有接收时，会等待，如果再出现连续3次重复接收这个ACK时，会重发该段。这种机制比起超时机制可以提供更加快速的重发服务。\n  流控制。 发送端控制时，应该考虑接收端的情况，这样可以避免触发重发机制。TCP提供一种机制可以发送端根据接收端的实际接收能力控制发送的数据量。具体的操作是， 接收端主机想发送端主机通知自己可以接收的数据大小，于是发送端会发送不超过这个限度的数据。该大小限制就被称为串口大小。窗口大小的值由接收端主机来决定。\n   TCP首部中，专门有这个字段来通知窗口大小。接收主机将自己可以接收的缓冲区大小放入这个字段中通知给发送端。这个字段越大，说明网络的吞吐量越高。不过当接收端这个缓冲区一旦面临数据溢出时，窗口大小的值会随之被设置为一个更小的值通知给发送端，从而控制数据发送量。这样就形成了一个完整的TCP流控制。\n 当接收端缓冲区满，不得不停止接收数据。之后，在收到窗口更新通知后通信才得继续运行。如果窗的更新通知在传送中丢失，可能导致无法继续通信。为避免此类问题的发生，发送端主机会时不时的发送一个叫窗口探测的数据段，此数据段仅含一个字节以获取最新的窗口大小信息。\n 拥塞控制  ","id":10,"section":"posts","summary":"TCP是面向连接的协议，它提供持续可交付的可靠连接。充分实现了数据传输时的各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行","tags":["tcp/ip","网络"],"title":"交换机网关","uri":"https://ketop.github.io/2018/08/internet02/","year":"2018"},{"content":"网络的组成要素  中继器   中继器是在OSI模型的第一层\u0026ndash;物理层面上延长网络的设备。由电缆传过来的电信号或光信号经由中继器的波形调整和放大再传给另一个电缆。它无法判断数据的错误，不能再传输速度不同的媒介之间转发。 中继集线器指可以连接多个端口的中继器，也成为中继集线器或集线器。\n 网桥/2层交换机    网桥是在OSI模型的第2层\u0026ndash;数据链路层面上连接两个网络设备。它能识别数据链路层中的数据帧，并将这些数据帧暂时存储于内存，在重新生成信号作为一个全新的帧转发给相连的另一个网段。 由于能够存储这些数据帧，故能够链接传输速率完全不同的数据链路，并且不限制连接网段的个数。此外数据链路的数据帧中有一个FCS数据位，可用于校验数据是否正确送往目的地。网桥通过检查这个域的值，讲那些损坏的数据丢弃，从而避免发送给其他的网段。 此外，网桥还能通过MAC地址自学机制和过滤功能控制网络流量。 有些网桥能够判断是否将数据报文发送给相邻的网段，该网桥又称为自学式网桥。它会记住曾经通过自己转发的所有数据帧的MAC地址，并保存到内存表中，下次直接将数据帧发送到对应网段。 以太网等网络中经常使用的交换集线器，现在基本也属于网桥中的一种。交换集线器中连接电缆的每个端口都能提供类似网桥的功能。   路由器/3层交换机   路由器是在OSI模型的第3层\u0026ndash;网络层面上连接连接两个网络、并对分组报文进行转发的设备。网桥是根据MAC地址进行处理的，而路由器则是根据IP地址进行处理的。路由器可以连接两个不同的数据链路。路由器还有分担网络负荷的作用，甚至有些路由器具备一定的网络安全功能。\n 4~7层交换机   4~7层交换机负责处理OSI模型中从传输层至应用层的数据。如果用TCP/IP分层模型表述，该交换机处理以TCP等协议的传输层及其上的应用层为基础，分析收发数据，并对其进行特定的处理。\n 例如并发访问量非常大的一个企业级Web站点，使用一台服务器不足以满足前端的访问需求，此时需要架设多台服务器来分担。这些服务器前端的访问入口地址通常只有一个。为了能通过同一个URL将前端访问分发到后台多个服务器，可以在这些服务器的前端加上一个负载均衡器。这种负载均衡器就是4~7层交换机的一种。 实际通信中，在网络比较拥堵时，希望优先处理像语音这类对及时性要求较高的通信请求，放缓像邮件或数据转发等稍有延迟也并无大碍的通信请求。这种处理被称为带宽控制，也是4~7层交换机的重要功能之一。此外还有广域网加速器、特殊应用访问加速以及防火墙等。   网关   网关是OSI参考模型中负责将从传输层到应用层的数据进行转换和转发的设备。网关不仅转发数据还负责对数据进行转换，它通常会使用一个表示层或应用层网关，在两个不能直接通信的协议之间进行翻译，最终实现两者之间的通信。\n 典型的例子就是互联网邮件与手机邮件之间的转换服务。手机邮件有可能会与互联网邮件互不兼容，这是由于它们在表示层与应用层中的“电子邮件协议”互不相同所导致的。在手机邮件服务器与互联网邮件之间会设置一个邮件网关，用于它们之间的转换。 为了控制网络流量以及出于安全考虑，有时会使用代理服务器(Proxy Server).这种代理服务器也是网关的一种，称为应用网关。有了代理服务器，客户端与服务器之间无需再网络层上直接通信，而是从传输层到应用层对数据和访问进行各种控制和处理。防火墙就是一款通过网关通信，针对不同应用提高安全性的产品。   ","id":11,"section":"posts","summary":"网络的组成要素 中继器 中继器是在OSI模型的第一层\u0026ndash;物理层面上延长网络的设备。由电缆传过来的电信号或光信号经由中继器的波形调整和放","tags":["tcp/ip","网络"],"title":"网络传输组成要素","uri":"https://ketop.github.io/2018/08/internet01/","year":"2018"}],"tags":[{"title":"c/c++","uri":"https://ketop.github.io/tags/c/c++/"},{"title":"github","uri":"https://ketop.github.io/tags/github/"},{"title":"hugo","uri":"https://ketop.github.io/tags/hugo/"},{"title":"psqlODBC","uri":"https://ketop.github.io/tags/psqlodbc/"},{"title":"SQLBindParameter","uri":"https://ketop.github.io/tags/sqlbindparameter/"},{"title":"tcp/ip","uri":"https://ketop.github.io/tags/tcp/ip/"},{"title":"travis-ci","uri":"https://ketop.github.io/tags/travis-ci/"},{"title":"ubuntu","uri":"https://ketop.github.io/tags/ubuntu/"},{"title":"unixODBC","uri":"https://ketop.github.io/tags/unixodbc/"},{"title":"wsl","uri":"https://ketop.github.io/tags/wsl/"},{"title":"网络","uri":"https://ketop.github.io/tags/%E7%BD%91%E7%BB%9C/"},{"title":"设计模式","uri":"https://ketop.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}
<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>wsl on Ketop's Realm</title><link>https://ketop.github.io/tags/wsl/</link><description>Recent content in wsl on Ketop's Realm</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Wed, 20 Jan 2021 21:45:13 +0000</lastBuildDate><atom:link href="https://ketop.github.io/tags/wsl/index.xml" rel="self" type="application/rss+xml"/><item><title>UTF8字符解析错误PG执行失败</title><link>https://ketop.github.io/2022/08/psqlodbc/</link><pubDate>Wed, 17 Aug 2022 20:25:01 +0800</pubDate><guid>https://ketop.github.io/2022/08/psqlodbc/</guid><description>最近在团队项目中发现，应用在使用unixodbc bind方式执行insert语句时报错： ERROR: invalid byte sequence for encoding “UTF8“: 0x08 遇到这个错误，最开始我们</description></item><item><title>设计模式-单例模式</title><link>https://ketop.github.io/2021/04/singleton/</link><pubDate>Mon, 26 Apr 2021 00:04:47 +0800</pubDate><guid>https://ketop.github.io/2021/04/singleton/</guid><description>饿汉模式 在程序开始时就完成实例化操作。 #include &amp;lt;iostream&amp;gt; #include &amp;lt;memory&amp;gt; class Singleton { private: Singleton(){ std::cout &amp;lt;&amp;lt; &amp;quot;Constructor&amp;quot; &amp;lt;&amp;lt; std::endl; } ~Singleton() { std::cout &amp;lt;&amp;lt; &amp;quot;Deconstructor&amp;quot; &amp;lt;&amp;lt; std::endl; } Singleton(const Singleton&amp;amp;)=delete; Singleton&amp;amp; operator=(const Singleton&amp;amp;)=delete; static Singleton m_instance; public: static Singleton* getInstance() { return &amp;amp;m_instance; } void echo() { std::cout &amp;lt;&amp;lt; &amp;quot;Print All Message.&amp;quot; &amp;lt;&amp;lt; std::endl; } };</description></item><item><title>win10 wsl</title><link>https://ketop.github.io/2021/01/wsl/</link><pubDate>Wed, 20 Jan 2021 21:45:13 +0000</pubDate><guid>https://ketop.github.io/2021/01/wsl/</guid><description>windows wsl可以很方便的让我们在win10中运行各种发行版的linux。但是在使用wsl之后，我安装了很多软件，直接导致在wsl ubuntu中再</description></item><item><title>C++可调用对象</title><link>https://ketop.github.io/2020/12/callable/</link><pubDate>Mon, 07 Dec 2020 22:30:07 +0800</pubDate><guid>https://ketop.github.io/2020/12/callable/</guid><description>c++11之前的可调用对象有：函数，函数指针，以及重载operator()运算符的对象。C++11之后，新增了可调用对象lambda表达式和</description></item><item><title>使用travis ci自动化发布hugo博客</title><link>https://ketop.github.io/2020/09/2020-09-17-travis-ci/</link><pubDate>Fri, 18 Sep 2020 20:20:18 +0800</pubDate><guid>https://ketop.github.io/2020/09/2020-09-17-travis-ci/</guid><description>hugo博客使用方法 使用hugo new site命令来生成博客站点的目录结构 在themes目录下安装自己喜欢的主题，例如我这里的Pure 拷贝主题下</description></item><item><title>Ubuntu 18.04 LTS美化配置</title><link>https://ketop.github.io/2020/04/2020-04-05-helloubuntu/</link><pubDate>Thu, 16 Apr 2020 16:14:24 +0800</pubDate><guid>https://ketop.github.io/2020/04/2020-04-05-helloubuntu/</guid><description>终于又从Archlinux切换到了Ubuntu 18.04 LTS. 原因是发现archlinux确实不稳定，每次滚动升级概率性出现桌面无法启动的现象。 那么这次</description></item><item><title>C++控制类对象实例化仅在栈或者堆上的方法</title><link>https://ketop.github.io/2019/04/cpp_instance/</link><pubDate>Wed, 24 Apr 2019 17:29:14 +0800</pubDate><guid>https://ketop.github.io/2019/04/cpp_instance/</guid><description>实例化一个类有两种方式 静态实例化。编译器自动在栈上分配内存，然后调用构造函数。实例对象离开所在作用域后，执行析构函数，然后由编译器自动回收栈</description></item><item><title>C++拷贝构造函数</title><link>https://ketop.github.io/2018/08/2020-04-05-c-%E8%AF%AD%E6%B3%952/</link><pubDate>Thu, 16 Aug 2018 20:25:01 +0800</pubDate><guid>https://ketop.github.io/2018/08/2020-04-05-c-%E8%AF%AD%E6%B3%952/</guid><description>当定义一个类时， 我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些对象， 包括： 拷</description></item><item><title>C++移动构造函数</title><link>https://ketop.github.io/2018/08/2020-04-05-c-%E8%AF%AD%E6%B3%95/</link><pubDate>Thu, 16 Aug 2018 20:20:18 +0800</pubDate><guid>https://ketop.github.io/2018/08/2020-04-05-c-%E8%AF%AD%E6%B3%95/</guid><description>为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是</description></item><item><title>IP协议</title><link>https://ketop.github.io/2018/08/internet03/</link><pubDate>Thu, 16 Aug 2018 19:49:14 +0800</pubDate><guid>https://ketop.github.io/2018/08/internet03/</guid><description>TCP/IP的心脏是互联网层。该层主要由IP协议与ICMP(Internet Control Message Protocol)两个协议组成。 IP协议 IP相当与OSI模型</description></item><item><title>交换机网关</title><link>https://ketop.github.io/2018/08/internet02/</link><pubDate>Thu, 16 Aug 2018 19:48:06 +0800</pubDate><guid>https://ketop.github.io/2018/08/internet02/</guid><description>TCP是面向连接的协议，它提供持续可交付的可靠连接。充分实现了数据传输时的各种控制功能，可以进行丢包时的重发控制，还可以对次序乱掉的分包进行</description></item><item><title>网络传输组成要素</title><link>https://ketop.github.io/2018/08/internet01/</link><pubDate>Thu, 16 Aug 2018 19:46:00 +0800</pubDate><guid>https://ketop.github.io/2018/08/internet01/</guid><description>网络的组成要素 中继器 中继器是在OSI模型的第一层&amp;ndash;物理层面上延长网络的设备。由电缆传过来的电信号或光信号经由中继器的波形调整和放</description></item><item><title/><link>https://ketop.github.io/about/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://ketop.github.io/about/</guid><description>nice to see you.</description></item></channel></rss>
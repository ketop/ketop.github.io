---
title: "C++拷贝构造函数"
date: 2018-08-16T20:25:01+08:00
draft: true
tags: [c/c++]
---
当定义一个类时， 我们显式地或隐式地指定在此类型的对象拷贝、移动、赋值和销毁时做什么。一个类通过定义五种特殊的成员函数来控制这些对象， 包括：
- 拷贝构造函数
- 拷贝赋值运算符
- 移动构造函数
- 移动赋值运算符
- 析构函数

拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么；拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么；析构函数定义了当此类型对象销毁时做什么。我们称这些操作为拷贝控制操作。

### 拷贝构造函数
```c++
 class Foo {
 public:
 	Foo(); //默认构造函数
 	Foo(const Foo&);// 拷贝构造函数
 	//...
 };
 /*
   * 拷贝构造函数的第一个参数几乎总是一个自身类型的const引用
   * 拷贝构造函数在几种情况下都会被隐式地使用，因此构造函数
  * 通常不应该是explicity的
  */
```
#### 合成拷贝构造函数
如果我们没有为一个类定义拷贝构造函数，编译器会为我们定义一个。与合成默认构造函数不同， 即使我们定义了其他构造函数，编译器也会为我们合成一个拷贝构造函数。
一般情况下，合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中。编译器从给定的对象中依次将每个非static成员拷贝到正在创建的对象中。
每个成员的类型决定了它如何拷贝: 对类类型的成员，会使用其拷贝构造函数来拷贝；内置类型的成员则直接拷贝。对于数组成员，合成拷贝构造函数会逐元素地拷贝一个数组类型的成员。如果数组元素为类类型，则使用元素的拷贝构造函数来进行拷贝。
```c++
class Sales_data {
public:
	//其他成员和构造函数的定义，与以前一致
	//与合成拷贝构造函数等价的拷贝构造函数
	Sales_data(const Sales_data &);
private:
	std::string bookNo;
	unsigned units_sold - 0;
	double revenue = 0.0;
};
 
//与合成的拷贝构造函数等价的拷贝构造函数
Sales_data::Sales_data(const Sales_data &orig):
	bookNo(orig.bookNo), units_sold(orig.units_sold), revenue(orig.revenue)
{
 // empty
}
```
拷贝初始化与值初始化的区别
```c++
string dots(1o, '.');//直接初始化
string s(dots);//直接初始化
string s2 = dots;//拷贝初始化
string null_book = "9-999-99999-9";//拷贝初始化
string nines = string(100, '9');//拷贝初始化
```
当使用直接初始化时，实际上是编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当使用拷贝初始化时，我们要求将右侧运算对象拷贝到正在创建的对象中，如果需要的话将进行类型转换。
拷贝初始化通常使用拷贝构造函数来完成。但是，如果一个类有一个移动构造函数，则拷贝初始化有时会使用移动构造函数而非拷贝构造函数来完成。

拷贝初始化不仅在我们用=定义变量时会发生，下列情况也会发生
	• 将一个对象作为实参传递给一个非引用类型的形参
	• 从一个返回类型为非引用类型的函数返回一个对象
	• 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。
	• 某些类类型会对它们所分配的对象使用拷贝初始化。例如初始化标准容器或是调用其insert和push成员事，容器会对其元素进行拷贝初始化，与之相对的，用emplace成员创建的元素都进行直接初始化。

### 拷贝赋值运算符
```c++
class Foo {
public:
	Foo& operator=(const Foo &);//赋值运算符
	//..
};
```

#### 合成拷贝赋值运算符
与处理拷贝构造函数一样，如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。通常情况下，它将右侧运算对象的每个非static成员赋予左侧运算对象对应的成员，这一工作是通过成员类型的拷贝赋值运算符来完成的。对于数组类型的成员，逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。
```c++
/*等价于合成拷贝赋值运算符*/
Sales_data& Sales_data::operator=(const Sales_data &rhs)
{
	bookNo = rhs.bookNo; //调用string::operator=
	units_sold = rhs.units_sold;//内置的int赋值
	revenue = rhs.revenue;//内置的double赋值
	return *this;
}
```

### 析构函数
析构函数执行与构造函数相反的操作：构造函数初始化对象的非static数据成员，还可能做一些其他工作；析构函数释放对象使用的资源，并销毁对象的非static数据成员。
```c++
class Foo {
public:
	~Foo();//析构函数
	//...
};
```
析构函数没有返回值，也不接受参数。由于析构函数不接受参数，因此它不能被重载。对于一个给定类，只有唯一一个析构函数。
在一个构造函数中，成员初始化是在函数体执行之前完成的，且按照它们在类中出现的顺序进行初始化。在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。
在对象最后一次使用后，析构函数的函数体可执行类设计者希望执行的任何收尾工作。通常，析构函数释放对象在生存期分配的所有资源。在析构函数中不存在类似于构造函数中初始化列表的东西来控制成员如何销毁，析构部分是隐式的。成员销毁时完全以来于成员的类型。销毁类类型成员会执行其对应的析构函数。内置类型没有析构函数，因此销毁内置类型成员什么也不需要做。与普通指针不同，智能指针是类类型，所以具有析构函数，因此与普通指针不同，智能指针成员在析构阶段会被自动销毁。

析构函数在对象被销毁时自动调用。
	• 变量离开其作用域时被销毁
	• 当一个对象被销毁时，其成员被销毁
	• 容器（无论是标准容器还是数组）被销毁时，其元素被销毁
	• 对于动态分配的对象，当对指向它的指针应用delete运算符时被销毁
	• 对于临时对象，当创建它的完整表达式结束时被销毁

#### 合成析构函数
当一个类未定义自己的析构函数时，编译器会为它定义一个合成析构函数。通常情况下，合成的析构函数体为空。对于某些类，合成析构函数被用来阻止该类型的对象被销毁。析构函数体自身并不直接销毁成员，成员是在函数体执行之后隐含的析构阶段中被销毁的。在整个对象销毁过程中，析构函数体是作为成员销毁步骤之外的另一部分而进行的。



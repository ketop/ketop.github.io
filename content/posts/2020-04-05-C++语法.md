---
title: "C++移动构造函数"
date: 2018-08-16T20:20:18+08:00
draft: false
tags: [c/c++]
---
为了让我们自己的类型支持移动操作，需要为其定义移动构造函数和移动赋值运算符。这两个成员类似对应的拷贝操作，但它们从给定对象“窃取”资源而不是拷贝资源，

## 移动构造函数
移动构造函数的第一个参数是该类型的一个右值引用，类似于拷贝构造函数，任何额外的参数都必须有默认实参。
除完成资源移动，移动构造函数还必须确保移后源处于这样一种状态：销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源--这些资源的所有权已经归属新创建的对象。
```c++
 class StrVec {
 public:
 	StrVec():
 		elements(nullptr), first_free(nullptr), cap(nullptr) {}
 	StrVec(const StrVec&);
 	StrVec &operator=(const StrVec&);
 	StrVec(StrVec &&) noexcept;
 	StrVec& operator=(StrVec &&) noexcept;
 	
 	
 	~StrVec();
 	//....
 private:
 	static std::allocator<std::string> alloc;
 	void chk_n_alloc() {if(size() == capacity()) reallocate(); }
 	std::pair<std::string*, std::string*>alloc_n_copy
 		(const std::string*, const std::string*);
 	void free();
 	void reallocate();
 	std::string *elements;
 	std::string *first_free;
 	std::string *cap;
 };

 StrVec::StrVec(StrVec &&s)  noexcept
 	: elements(s.elements), first_free(s.first_free), cap(s.cap)
 {
 	s.elements = s.first_free = s.cap = nullptr;
 }

```

与拷贝构造函数不同，移动构造函数不分配任何新内存；它接管给定的strVec中的内存。在接管内存后，它将给定对象中的指针都置为nullptr。这样就完成了从给定对象的移动操作，此对象将继续存在。最终，移后源对象会被销毁，意味着将在其上运行析构函数。
StrVec的析构函数在first_free上调用deallocate.如果我们忘了改变s.first_free,则销毁移后源对象就会释放掉我们刚刚移动的内存。

由于移动操作“窃取”资源，它通常不分配仍和资源。因此，移动操作通常不会抛出任何异常。当编写一个不抛出异常的移动操作时，我们应该将此事通知标准库。默认的标准库会认为移动我们的类对象时可能抛出异常，而且会为了处理这种可能性而做一些额外的工作。

通知标准库的方法是在构造函数中指明noexcept。在一个构造函数中，noexcept出现在参数列表和初始化列表开始的冒号之间。我们必须在类的头文件的声明和定义中都指定noexcept。
不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept.

### 合成的移动操作
与拷贝构造函数不同，编译器根本不会为某些类合成移动操作。特别的，如果一个类定义了自己的拷贝构造函数、拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符了。

只有当一个类没有定义任何自己版本的拷贝控制成员，且类的每个static数据成员都可以移动时，编译器才会合成移动构造函数或移动赋值运算符。编译器可以移动内置类型的成员；如果一个成员是类类型，且该类有对应的移动操作，编译器也能移动这个成员。


与拷贝操作不同， 移动操作永远不会隐式定义为删除的函数。但是如果我们要求编译器生成=default的移动操作，且编译器不能移动所有成员，则编译器会将移动操作定义为删除的函数。 除了一个重要的例外，什么时候将合成的移动操作定义为删除的函数遵循与定义删除的合成拷贝操作类似的原则。
	• 移动构造函数被定义为删除的函数的条件是：有类成员定义了自己的拷贝构造函数且未定义移动构造函数；或者有类成员未定义自己的拷贝构造函数且编译器不能为其合成移动构造函数。移动赋值运算符类似
	• 如果有类成员的移动构造函数或移动赋值运算符被定义为删除的或是不可访问的，则类的移动构造函数或移动赋值运算符被定义为删除的
	• 类似拷贝构造函数，如果类的析构函数被定义为删除的或者不可访问的，则类的移动构造函数被定义为删除的。
	• 类似拷贝赋值运算符，如果有类成员是const的或引用， 则类的移动赋值运算符被定义为删除的。
	

移动操作和合成的拷贝控制成员还有最后一个相互作用的关系：一个类是否定义了自己的移动操作对拷贝操作如何合成有影响。如果类定义了一个移动构造函数和/或一个移动赋值运算符，则该类的合成拷贝构造函数和拷贝赋值运算符会被定义为删除的。
即定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作，否则，这些成员默认地被定义为删除的。

当一个类既有移动构造函数，也有拷贝构造函数，编译器使用普通的函数匹配规则来确定使用哪种构造函数。赋值操作的情况类似。
如果没有移动构造函数，右值也被拷贝。即使我们试图通过调用move来移动它们。
```c++
class Foo {
 public:
 	Foo() = default;
 	Foo(const Foo&);
 	//其他成员定义， 但Foo未定义移动构造函数
 };
 Foo x;
 Foo y(x);    //拷贝构造函数；x是一个左值
 Foo z(std::move(x));//拷贝构造函数，因未定义移动构造函数
```

实际上std::move(x)返回 Foo &&， 我们可以将Foo&&转换为const Foo&.因此z的初始化将使用Foo的拷贝构造函数。值得注意的是，使用拷贝构造函数替代移动构造函数几乎肯定是安全的。一般情况下，拷贝构造函数满足对应的移动构造函数的要求：它会拷贝给定对象，并将原对象置于有效状态。实际上，拷贝构造函数甚至不会改变原对象的值。

拷贝并交换赋值运算符和移动操作
```c++
class HasPtr {
public:
	/*添加的移动构造函数*/
	HasPtr(HasPtr &&p) noexcept: ps(p.ps), i(p.i) {p.ps = 0;}
	/*赋值运算符既是移动赋值运算符，也是拷贝赋值运算符*/
	HasPtr& operator=(HasPtr rhs){swap(*this, rhs); return *this;}
};
```


## 更新三/五法则
所有的五个拷贝控制成员应该看作一个整体：一般来说，如果一个类定义了任何一个拷贝操作，它就应该定义所有五个操作。如前所述，某些类必须定义拷贝构造函数、拷贝赋值运算符和析构函数才能正确工作。这些类通常拥有一个资源，而拷贝成员必须拷贝此资源。一般来说，拷贝一个资源会导致一些额外的开销。在这种拷贝并非必要的情况下，定义了移动构造函数和移动赋值运算符的类就可以避免此问题。


## 建议
只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能使用移动操作。
由于一个移后源对象具有不确定的状态，对其调用std::move是危险的。当我们调用move时，必须绝对确认移后源对象没有其他用户。
通过在类代码中小心地使用move，可以大幅提升性能。而如果随意在普通用户代码（与类实现代码相对）中使用移动操作，很可能导致莫名其妙的、难以查找的错误，而难以提升应用程序性能。

